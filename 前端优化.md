### 1. 首屏速度
首屏速度通常可以从「从输入URL到页面加载完成」这个过程入手：
+ 通过懒加载、资源压缩等的方式**减少首屏资源的大小**
+ 通过预拉取、BFF、模版注入等方式**减少网络请求的次数或时间**
+ 通过缓存、CDN、开启Gzip等方式，**在网络传输过程中进行优化**
+ 通过SSR(服务器端渲染)提前渲染好HTML，**减少首屏UI网络请求次数和渲染耗时**
+ 最后当资源加载好后，以最快的速度将页面渲染出来

### 2.网络传输过程中的优化
+ **减少HTTP请求**
<br>若服务端端还是使用的HTTP 1.1协议，那么浏览器并发的HTTP请求数量是有限制的，如果同时并发过多请求那么超过限制数量的请求便需要等待其他请求完成后才能进行，这样将会延长整个页面的加载时间。
+ **充分利用缓存**
<br>项目中有许多依赖库，例如React、Webpack、Vue等，这些依赖库的文件是基本不会发生变化的，因此可以将这些不会发生变化的文件单独拆分出来，并给他们加上缓存设置，那么之后的请求将不会再次请求加载这些资源，由此可以提升网站的整体性能。
+ **压缩资源文件**
<br>文件大小越小加载速度越快，因此可对代码进行压缩，去掉空格、注释、变量替换，也可以使用minify、gzip等压缩工具。
+ **DNS预解析**
<br>现代浏览器在DNS Prefetch上做了两项工作：
    + HTML源码下载完成后，会解析页面中所包含的链接，提前查询对应的域名。
    + 对于访问过的页面，浏览器会记录一份域名列表，当再次打开时会在HTML下载的同时去解析DNS。
+ CDN
<br>CDN(Content Delivery Network)即内容分发网络，其原理是尽可能的在各个地方分布机房缓存数据，因此，我们可以将静态资源尽量使用CDN加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个CDN域名。
+ 预加载和懒加载
    + 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，由此达到极快的加载速度。
    + 懒加载：把需要加载的图片路径替换成体积极小的占位图片的路径，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径让图片显示出来。
    + 异同点：两者的目的都是为了优化前端性能，提供更好的用户体验。区别在于两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载，懒加载能一定程度上缓解服务器的压力，而预加载则会增加服务器的压力。
+ 图片优化
    + 很多时候会使用到修饰类图片，这些修饰图片完全可以用CSS来代替。
    + 小图使用base64格式。
    + 将多个图标文件整合到一张图中即常说的雪碧图。
    + 采用正确的图片格式
        + 对于能够显示WebP格式的浏览器尽量使用WebP格式，因为WebP格式具有更好的图像数据压缩算法，能带来更小的图片体积。
        + 色彩很多的图片则适合使用JPEG格式的文件。
        + 色彩种类较少的图片则可以使用PNG格式，有的可以使用SVG文件代替。

### 3. 优化JavaScript
+ 将JS脚本放在页面底部，加快渲染速度
<br>JS引擎是独立于渲染引擎存在的，当HTML解析器遇到一个`<script>`标签时，它会暂停渲染过程并将控制权交给JS引擎，等JS引擎运行完毕，浏览器才会把控制权还给渲染引擎，继续CSSOM和DOM的构建。因此将JS脚本放在底部有利用加快首屏时间，避免浏览器因为执行JS代码而阻塞页面渲染。
+ 非核心代码异步加载
<br>利用JS创建一个`<script>`标签再插入到页面中，或利用defer/async加载JS文件。
+ 使用节流和防抖
<br>链接博客中解释的非常清楚 https://segmentfault.com/a/1190000018428170
+ 其他JS编码规范
    + 将JS脚本将脚本成组打包，减少HTTP请求次数
    + 使用非阻塞的方式下载JS脚本
    + 尽量减少使用闭包
    + 减少对象成员嵌套

### 4. 浏览器渲染
+ 浏览器渲染的过程
    + 解析HTML构建DOM，并行请求CSS/JS以及图片等资源文件
    + CSS文件下载完成，开始构建CSSOM
    + CSSOM构建结束后，和DOM一起生成Render Tree，即渲染树
    + 计算出每个节点在屏幕中的位置，通常称作Layout，即布局
    + 通过显卡把页面画到屏幕上Painting，即绘制
+ 重绘与回流的关系
    + 重绘(repaint)：当渲染树中的元素外观（如：颜色）发生改变并且不影响布局时，触发重绘事件
    + 回流(reflow)：当渲染树中的元素的布局（如：尺寸、位置）发生改变时，触发回流事件，并在回流后触发重绘
    + 回流必将引起重绘，而重绘不一定会引起回流
    + JS中获取Layout属性值的方法，例如：offsetLeft、scrollTop、getComputedStyle等也会触发回流，因为浏览器需要通过回流计算最新值
+ 会触发回流的事件
    + 页面渲染器初始化
    + 添加或删除可见的DOM元素
    + 元素的位置/尺寸/内容的改变
    + 浏览器窗口尺寸改变
+ 减少重绘和回流次数能有效提升前端性能
    + 需要要对DOM元素进行复杂的操作时，可以先其隐藏`display:"none"`，操作完成后再显示，避免页面在操作过程中多次重绘和回流
    + 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入页面中，或使用字符串拼接方式构建好对应HTML后再使用innerHTML来修改页面
    + 缓存使用过的Layout属性值，这样多次查询只会产生一次回流
    + 尽量避免用table布局，table中任意元素触发回流会导致整个table回流
    + 尽量使用CSS属性简写，例如border、background、font等，一次设置多个CSS属性，减少重绘和回流次数

### 5. Webpack优化
+ **Tree Shaking**：删除项目中未被引用的代码，减小打包后的文件体积。
+ **Scope Hoisting**：分析出模块之间的依赖关系，尽可能将需要打包的模块合并到一个函数中去，目的也是减小打包后的文件体积。
+ **HappyPack**：Webpack在打包的过程中是单线程的，在执行Loader时需要长时间编译的任务很多，HappyPack可以将Loader转换为并行执行，大幅提高打包效率。
+ **DllPlugin**：可以将特定的类库提前打包然后引入，这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包。
+ **UglifyJS**：UglifyJS能够有效压缩JS代码，压缩后的JS文件体积显著减小。

### 6. SEO优化
+ 合理的title/description/keywords
    + 搜索对着三项的权重逐个减小，即title > description > keywords
    + **title**：强调重点即可，重要关键词出现不要超过2次，不同页面title要有所不同
    + **description**：把页面内容高度概括且长度合适，不可过分堆砌关键词，不同页面description要有所不同
    + **keywords**：列举出重要关键词即可
+ 使用语义化的HTML标签，语义化标签让搜索引擎更容易理解网页
+ 重要内容的HTML代码放在靠前位置，搜索引擎抓取HTML的顺序是从上到下，有的搜索引擎对抓取长度有限制，因此要保证重要内容一定会被抓取
+ 重要内容不要用JS输出，因为爬虫不会执行JS获取内容
+ 少用iframe，因为搜索引擎不会抓取iframe中的内容
+ 非装饰性图片必须加alt
+ 提高网站速度，网站速度是搜索引擎排序的一个重要指标

### 7. 雅虎军规
https://github.com/huyaocode/webKnowledge/blob/master/5-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9B%85%E8%99%8E%E5%86%9B%E8%A7%84.md





